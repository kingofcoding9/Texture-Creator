<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Wireframe Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .checkerboard {
            background-color: #1a1a1a;
            background-image:
              linear-gradient(45deg, #222 25%, transparent 25%),
              linear-gradient(-45deg, #222 25%, transparent 25%),
              linear-gradient(45deg, transparent 75%, #222 75%),
              linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .custom-scrollbar::-webkit-scrollbar { width: 10px; height: 10px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1f2937; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 5px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        canvas {
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen font-sans flex flex-col">

    <div class="container mx-auto p-6 max-w-6xl flex-grow">
        <header class="mb-10 text-center">
            <h1 class="text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-indigo-500 mb-4">Smart Wireframe Generator</h1>
            <p class="text-gray-400 text-lg">Intelligent UV Mapping & High-Res Texture Generation</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8 items-start">
            
            <!-- Controls -->
            <div class="lg:col-span-4 space-y-8">
                
                <!-- Upload -->
                <div class="bg-gray-800 p-8 rounded-xl shadow-2xl border border-gray-700">
                    <div class="flex items-center justify-between mb-4">
                        <label class="text-lg font-bold text-blue-300">1. Upload Model</label>
                        <span id="statusBadge" class="px-2 py-1 text-[10px] font-bold uppercase tracking-wider text-gray-500 bg-gray-900 rounded">Waiting</span>
                    </div>
                    
                    <div class="relative group">
                        <div class="absolute -inset-0.5 bg-gradient-to-r from-blue-500 to-indigo-500 rounded-lg blur opacity-20 group-hover:opacity-50 transition duration-200"></div>
                        <div class="relative border-2 border-dashed border-gray-600 bg-gray-800 rounded-lg p-8 text-center hover:bg-gray-750 transition-colors cursor-pointer" onclick="document.getElementById('fileInput').click()">
                            <div class="space-y-2">
                                <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true">
                                    <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                </svg>
                                <p class="text-gray-300 text-sm font-medium" id="fileNameDisplay">Drop .geo.json or .bbmodel here</p>
                            </div>
                            <input type="file" id="fileInput" accept=".bbmodel,.obj,.json,.txt" class="hidden" onchange="handleFileSelect(event)">
                        </div>
                    </div>
                    <div id="fileInfo" class="mt-4 p-3 bg-gray-900 rounded text-xs text-gray-400 hidden">
                        <div class="flex justify-between"><span>Type:</span> <span id="fileTypeVal" class="text-white"></span></div>
                        <div class="flex justify-between"><span>File Header Res:</span> <span id="fileResVal" class="text-white"></span></div>
                    </div>
                </div>

                <!-- Settings Panel -->
                <div id="actionPanel" class="bg-gray-800 p-6 rounded-xl shadow-2xl border border-gray-700 opacity-50 pointer-events-none transition-all duration-300">
                    <label class="block text-lg font-bold mb-4 text-indigo-300">2. Settings</label>
                    
                    <!-- Target Resolution -->
                    <div class="mb-3">
                        <label class="text-xs text-gray-300 block mb-1">Target Output Resolution (Quality)</label>
                        <select id="targetResInput" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-2 text-sm text-white focus:outline-none focus:border-indigo-500">
                            <option value="512">512 x 512 (Standard)</option>
                            <option value="1024">1024 x 1024 (HD)</option>
                            <option value="2048" selected>2048 x 2048 (2K)</option>
                            <option value="4096">4096 x 4096 (4K)</option>
                        </select>
                    </div>
                    
                    <!-- Resolution Correction -->
                    <div class="bg-indigo-900/30 p-3 rounded mb-4 border border-indigo-500/50">
                        <label class="text-xs text-indigo-200 font-bold block mb-1">Source UV Grid (From File)</label>
                        <p class="text-[10px] text-gray-400 mb-2">Original resolution defined in file. <span class="text-green-400">Scale is 1:1 (Raw). Use slider to resize.</span></p>
                        <div class="flex gap-2 mb-2">
                             <input type="number" id="sourceWInput" class="flex-1 bg-gray-900 border border-gray-600 rounded px-2 py-1 text-xs text-white" value="0" oninput="requestRedraw()">
                             <span class="text-gray-500 self-center">x</span>
                             <input type="number" id="sourceHInput" class="flex-1 bg-gray-900 border border-gray-600 rounded px-2 py-1 text-xs text-white" value="0" oninput="requestRedraw()">
                        </div>
                        
                        <!-- Manual Scale Slider -->
                        <div class="mt-3 mb-2">
                             <label class="text-[10px] text-indigo-200 font-bold block mb-1 flex justify-between">
                                <span>Manual Scale Multiplier</span>
                                <span id="scaleMultDisplay" class="text-white">1.00x</span>
                            </label>
                            <input type="range" id="manualScaleInput" min="0.1" max="2.0" step="0.01" value="1.0" class="w-full accent-indigo-500" oninput="updateScaleDisplay(); requestRedraw()">
                        </div>

                        <!-- Info: Drag Instructions -->
                        <div class="mt-2 p-2 bg-black/40 rounded text-[10px] text-gray-400 flex flex-col gap-1">
                            <div class="flex justify-between"><span class="font-bold text-indigo-400">OFFSET X:</span> <span id="offsetXDisplay" class="font-mono text-white">0%</span></div>
                            <div class="flex justify-between"><span class="font-bold text-indigo-400">OFFSET Y:</span> <span id="offsetYDisplay" class="font-mono text-white">0%</span></div>
                            <div class="text-center italic mt-1 text-gray-500">Drag wireframe on preview to move</div>
                        </div>
                    </div>
                    
                    <!-- Background & Lines -->
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="text-xs text-gray-400 block mb-1">Background Opacity</label>
                            <input type="range" id="bgOpacity" min="0" max="1" step="0.1" value="0" class="w-full accent-indigo-500">
                        </div>
                        <div>
                            <label class="text-xs text-gray-400 block mb-1">Line Width</label>
                            <input type="range" id="lineWidthMult" min="0.1" max="3" step="0.1" value="1.0" class="w-full accent-indigo-500" oninput="requestRedraw()">
                        </div>
                         <div>
                            <label class="text-xs text-gray-400 block mb-1">Line Color</label>
                            <input type="color" id="strokeColor" value="#38bdf8" class="w-full h-8 bg-gray-900 border border-gray-600 rounded cursor-pointer" oninput="requestRedraw()">
                        </div>
                         <div class="flex items-center h-full pt-4">
                             <input type="checkbox" id="fixInvertedCheckbox" class="w-5 h-5 text-indigo-600 bg-gray-700 border-gray-500 rounded focus:ring-indigo-500" onchange="requestRedraw()">
                            <label for="fixInvertedCheckbox" class="ml-2 text-xs text-gray-300 cursor-pointer select-none font-bold">Flip V (OpenGL)</label>
                        </div>
                    </div>


                    <button onclick="generateSmartWireframe()" class="w-full group relative flex justify-center py-3 px-4 border border-transparent text-sm font-bold rounded-lg text-white bg-indigo-600 hover:bg-indigo-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 shadow-lg transform transition hover:-translate-y-0.5">
                        Download Smart Assets
                    </button>
                </div>

                <!-- Logs -->
                <div class="bg-black/30 p-4 rounded-lg border border-gray-800">
                    <div class="text-[10px] font-mono text-gray-500 uppercase mb-2">System Log</div>
                    <div id="debugLog" class="font-mono text-xs text-green-500/80 h-24 overflow-y-auto whitespace-pre-wrap">Waiting...</div>
                </div>
            </div>

            <!-- Preview -->
            <div class="lg:col-span-8 h-[600px] bg-gray-800 rounded-xl shadow-2xl border border-gray-700 flex flex-col overflow-hidden relative">
                 <div class="absolute top-4 right-4 z-20 bg-black/70 backdrop-blur px-3 py-1 rounded text-xs text-white border border-white/10 pointer-events-none">
                    Preview Mode (Drag to Move)
                </div>
                <div class="flex-1 overflow-auto relative custom-scrollbar flex items-center justify-center bg-gray-900">
                    <div class="checkerboard absolute inset-0 z-0 opacity-50 pointer-events-none"></div>
                    <canvas id="textureCanvas" class="relative z-10 shadow-2xl max-w-none"></canvas>
                    <div id="placeholderText" class="absolute z-20 inset-0 flex flex-col items-center justify-center text-gray-600 pointer-events-none">
                        <svg class="w-16 h-16 mb-4 opacity-20" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd"></path></svg>
                        <span>No Model Loaded</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden High Res Canvas -->
    <canvas id="highResCanvas" style="display:none;"></canvas>

    <script>
        // --- CONFIGURATION ---
        const SETTINGS = {
            defaultRes: 16
        };

        // --- STATE ---
        let appState = {
            fileContent: null,
            fileType: null,
            sourceRes: { w: 64, h: 64 },
            hasMesh: false,
            fileName: '',
            // Offsets are stored as Percentage (0.0 - 1.0)
            offsetX: 0.0,
            offsetY: 0.0, // Default to 0 (No offset)
            isDragging: false,
            lastMouse: { x: 0, y: 0 }
        };

        // --- DOM ELEMENTS ---
        const dom = {
            canvas: document.getElementById('textureCanvas'),
            ctx: document.getElementById('textureCanvas').getContext('2d'),
            hrCanvas: document.getElementById('highResCanvas'),
            hrCtx: document.getElementById('highResCanvas').getContext('2d'),
            log: document.getElementById('debugLog'),
            fileInput: document.getElementById('fileInput'),
            status: document.getElementById('statusBadge'),
            panels: {
                action: document.getElementById('actionPanel'),
                fileInfo: document.getElementById('fileInfo'),
                placeholder: document.getElementById('placeholderText')
            },
            inputs: {
                flip: document.getElementById('fixInvertedCheckbox'),
                srcW: document.getElementById('sourceWInput'),
                srcH: document.getElementById('sourceHInput'),
                targetRes: document.getElementById('targetResInput'),
                bgOpacity: document.getElementById('bgOpacity'),
                lineWidthMult: document.getElementById('lineWidthMult'),
                manualScale: document.getElementById('manualScaleInput'),
                color: document.getElementById('strokeColor')
            },
            displays: {
                scale: document.getElementById('scaleMultDisplay'),
                offX: document.getElementById('offsetXDisplay'),
                offY: document.getElementById('offsetYDisplay')
            }
        };

        // --- UTILS ---
        function nextPowerOfTwo(n) {
            if (n === 0) return 1;
            n--;
            n |= n >> 1;
            n |= n >> 2;
            n |= n >> 4;
            n |= n >> 8;
            n |= n >> 16;
            return n + 1;
        }

        function log(msg) {
            const time = new Date().toLocaleTimeString('en-US', {hour12: false, hour: "numeric", minute: "numeric", second: "numeric"});
            dom.log.innerHTML += `[${time}] ${msg}\n`;
            dom.log.scrollTop = dom.log.scrollHeight;
        }

        function clearLog() {
            dom.log.textContent = '';
        }

        function updateScaleDisplay() {
            dom.displays.scale.textContent = parseFloat(dom.inputs.manualScale.value).toFixed(2) + 'x';
        }

        function updateOffsetDisplays() {
            dom.displays.offX.textContent = (appState.offsetX * 100).toFixed(1) + '%';
            dom.displays.offY.textContent = (appState.offsetY * 100).toFixed(1) + '%';
        }

        // --- DRAG INTERACTION ---
        dom.canvas.addEventListener('mousedown', startDrag);
        dom.canvas.addEventListener('touchstart', startDrag, {passive: false});

        window.addEventListener('mousemove', doDrag);
        window.addEventListener('touchmove', doDrag, {passive: false});

        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);

        function startDrag(e) {
            if (!appState.fileContent) return;
            appState.isDragging = true;
            const pt = getEventPoint(e);
            appState.lastMouse = pt;
            dom.canvas.style.cursor = 'grabbing';
        }

        function doDrag(e) {
            if (!appState.isDragging) return;
            e.preventDefault();
            
            const pt = getEventPoint(e);
            const dx = pt.x - appState.lastMouse.x;
            const dy = pt.y - appState.lastMouse.y;
            
            // Convert pixel delta to percentage of canvas size
            const rect = dom.canvas.getBoundingClientRect();
            
            appState.offsetX += dx / rect.width;
            appState.offsetY += dy / rect.height;
            
            appState.lastMouse = pt;
            
            updateOffsetDisplays();
            requestRedraw();
        }

        function endDrag() {
            appState.isDragging = false;
            dom.canvas.style.cursor = 'grab';
        }

        function getEventPoint(e) {
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }


        // --- FILE HANDLING ---
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('fileNameDisplay').textContent = file.name;
            appState.fileName = file.name;
            
            const reader = new FileReader();
            reader.onload = (e) => processFile(e.target.result);
            reader.readAsText(file);
        }

        function processFile(content) {
            appState.fileContent = content;
            clearLog();
            
            try {
                const json = JSON.parse(content);
                
                if (json["minecraft:geometry"]) {
                    appState.fileType = 'bedrock';
                    const geo = json["minecraft:geometry"][0];
                    
                    const headerW = geo.description.texture_width || 16;
                    const headerH = geo.description.texture_height || 16;

                    // --- INITIAL SETUP ---
                    log(`File Header: ${headerW}x${headerH}`);
                    log(`Loaded. No auto-scale. Drag/Scale manually.`);

                    // Set State & Inputs
                    appState.sourceRes.w = headerW;
                    appState.sourceRes.h = headerH;
                    
                    // Defaults: RAW (No divide by 2, No offset)
                    appState.offsetX = 0.0;
                    appState.offsetY = 0.0; 

                    dom.inputs.srcW.value = headerW;
                    dom.inputs.srcH.value = headerH;
                    dom.inputs.manualScale.value = "1.0"; 

                    // Update UI
                    updateUIState(true);
                    updateScaleDisplay();
                    updateOffsetDisplays();
                    document.getElementById('fileResVal').textContent = `${headerW}x${headerH}`;
                    
                    drawPreview();
                } else {
                    throw new Error("Invalid Bedrock file.");
                }
            } catch (e) {
                log(`Error: ${e.message}`);
                console.error(e);
                updateUIState(false);
            }
        }

        function updateUIState(isValid) {
            const { action, fileInfo, placeholder } = dom.panels;
            
            if(isValid) {
                action.classList.remove('opacity-50', 'pointer-events-none');
                fileInfo.classList.remove('hidden');
                placeholder.style.display = 'none';
                dom.status.textContent = "Ready";
                dom.status.className = "px-2 py-1 text-[10px] font-bold uppercase tracking-wider text-green-500 bg-green-900/30 rounded border border-green-800";
                
                document.getElementById('fileTypeVal').textContent = appState.fileType;
            } else {
                action.classList.add('opacity-50', 'pointer-events-none');
                fileInfo.classList.add('hidden');
                placeholder.style.display = 'flex';
                dom.status.textContent = "Error";
                dom.status.className = "px-2 py-1 text-[10px] font-bold uppercase tracking-wider text-red-500 bg-red-900/30 rounded border border-red-800";
            }
        }

        function requestRedraw() {
            if(appState.fileContent) drawPreview();
        }

        // ==========================================
        // DRAW PREVIEW
        // ==========================================
        function drawPreview() {
            const data = JSON.parse(appState.fileContent);
            const geo = data["minecraft:geometry"][0];
            
            const srcW = parseInt(dom.inputs.srcW.value) || 16;
            const srcH = parseInt(dom.inputs.srcH.value) || 16;

            const previewScale = Math.max(2, 1024 / srcW);
            const width = srcW * previewScale;
            const height = srcH * previewScale;
            
            dom.canvas.width = width;
            dom.canvas.height = height;
            dom.ctx.clearRect(0, 0, width, height);

            // MATH: 
            // 1. Base Scale = Preview / Source (Standard 1:1)
            // 2. User Multiplier
            const manualMult = parseFloat(dom.inputs.manualScale.value);
            const finalScaleX = previewScale * manualMult;
            const finalScaleY = previewScale * manualMult;
            
            // OFFSETS (Pixels)
            const offX = width * appState.offsetX;
            const offY = height * appState.offsetY;

            const settings = {
                scaleX: finalScaleX,
                scaleY: finalScaleY,
                targetH: height,
                offX: offX,
                offY: offY,
                flipV: dom.inputs.flip.checked,
                color: dom.inputs.color.value,
                lineWidth: 1 * parseFloat(dom.inputs.lineWidthMult.value),
                isExport: false,
                origW: srcW, 
                origH: srcH,
                fillBg: false
            };

            processGeometry(dom.ctx, geo, settings);
        }

        // ==========================================
        // GENERATE
        // ==========================================
        function generateSmartWireframe() {
            log("Generating Assets...");
            const data = JSON.parse(appState.fileContent);
            const geo = data["minecraft:geometry"][0];

            const targetRes = parseInt(dom.inputs.targetRes.value);
            const srcW = parseInt(dom.inputs.srcW.value) || 16;
            const srcH = parseInt(dom.inputs.srcH.value) || 16;
            
            // MATH: 
            // 1. Base Scale = Target / Source (Standard 1:1)
            // 2. User Multiplier
            const manualMult = parseFloat(dom.inputs.manualScale.value);
            const scaleX = (targetRes / srcW) * manualMult;
            const scaleY = (targetRes / srcH) * manualMult;
            
            // OFFSETS (Pixels relative to Target)
            const offX = targetRes * appState.offsetX;
            const offY = targetRes * appState.offsetY;

            log(`Target: ${targetRes}x${targetRes} | Source: ${srcW}x${srcH}`);
            log(`Multiplier: ${manualMult.toFixed(2)}x | Offsets: ${appState.offsetX.toFixed(2)}, ${appState.offsetY.toFixed(2)}`);

            geo.description.texture_width = targetRes;
            geo.description.texture_height = targetRes;

            dom.hrCanvas.width = targetRes;
            dom.hrCanvas.height = targetRes;
            dom.hrCtx.clearRect(0, 0, targetRes, targetRes);

            const bgOp = parseFloat(dom.inputs.bgOpacity.value);
            if(bgOp > 0) {
                dom.hrCtx.globalAlpha = bgOp;
                dom.hrCtx.fillStyle = "#000000"; 
                dom.hrCtx.fillRect(0, 0, targetRes, targetRes);
                dom.hrCtx.globalAlpha = 1.0;
            }

            const baseWidth = Math.max(1, targetRes / 2000); 
            const finalWidth = baseWidth * parseFloat(dom.inputs.lineWidthMult.value);

            const settings = {
                scaleX: scaleX,
                scaleY: scaleY,
                targetH: targetRes,
                offX: offX,
                offY: offY,
                flipV: dom.inputs.flip.checked,
                color: dom.inputs.color.value,
                lineWidth: finalWidth,
                isExport: true,
                origW: srcW,
                origH: srcH
            };

            processGeometry(dom.hrCtx, geo, settings);
            downloadFiles(dom.hrCanvas, data);
        }

        // ==========================================
        // PROCESSING LOGIC
        // ==========================================
        function processGeometry(ctx, geo, s) {
            ctx.strokeStyle = s.color;
            ctx.lineWidth = s.lineWidth;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            if(!geo.bones) return;

            geo.bones.forEach(bone => {
                if(bone.cubes) bone.cubes.forEach(cube => processCube(ctx, cube, s));
                if(bone.poly_mesh) processMesh(ctx, bone.poly_mesh, s);
            });
        }

        function processCube(ctx, cube, s) {
            if (Array.isArray(cube.uv)) {
                // BOX UV
                const [u, v] = cube.uv;
                const [w, h, d] = cube.size;
                const faces = [
                    [u + d, v + d, w, h], [u + d + w + d, v + d, w, h],
                    [u, v + d, d, h], [u + d + w, v + d, d, h],    
                    [u + d, v, w, d], [u + d + w, v, w, d]         
                ];

                faces.forEach(face => drawRect(ctx, face[0], face[1], face[2], face[3], s));

                if(s.isExport) {
                    cube.uv[0] *= s.scaleX;
                    cube.uv[1] *= s.scaleY;
                    
                    // Apply Offsets
                    cube.uv[0] += s.offX;
                    cube.uv[1] += s.offY;

                    if(s.flipV) {
                        const totalLayoutHeight = d + h;
                        cube.uv[1] = s.targetH - cube.uv[1] - (totalLayoutHeight * s.scaleY);
                    }
                }

            } else if (typeof cube.uv === 'object') {
                // PER-FACE UV
                Object.values(cube.uv).forEach(faceData => {
                    if(faceData.uv) {
                        const [u, v] = faceData.uv;
                        const [w, h] = faceData.uv_size || [0, 0];
                        drawRect(ctx, u, v, w, h, s);

                        if(s.isExport) {
                            faceData.uv[0] *= s.scaleX;
                            let newV = v * s.scaleY;
                            
                            // Apply Offsets
                            faceData.uv[0] = (faceData.uv[0] * s.scaleX) + s.offX;
                            newV = (v * s.scaleY) + s.offY;

                            if(s.flipV) {
                                faceData.uv[1] = s.targetH - newV - (h * s.scaleY); 
                            } else {
                                faceData.uv[1] = newV;
                            }

                            if(faceData.uv_size) {
                                faceData.uv_size[0] *= s.scaleX;
                                faceData.uv_size[1] *= s.scaleY;
                            }
                        }
                    }
                });
            }
        }

        function processMesh(ctx, mesh, s) {
            if (!mesh.polys || !mesh.uvs) return;
            
            const isNormalized = mesh.normalized_uvs === true;
            
            const transformedUVs = mesh.uvs.map(uv => {
                let u = uv[0];
                let v = uv[1];

                if (isNormalized) {
                    u = u * s.origW;
                    v = v * s.origH;
                }

                let finalX = u * s.scaleX;
                let finalY = v * s.scaleY;

                // Apply Offsets
                finalX += s.offX;
                finalY += s.offY;

                if(s.flipV && s.isExport) {
                    finalY = s.targetH - finalY;
                }

                return [finalX, finalY];
            });

            ctx.beginPath();
            mesh.polys.forEach(poly => {
                const indices = Array.isArray(poly) ? poly : (poly.indices || []);
                let first = true;
                indices.forEach(idxData => {
                    const uvIdx = Array.isArray(idxData) ? idxData[2] : idxData;
                    if(transformedUVs[uvIdx]) {
                        let [x, y] = transformedUVs[uvIdx];
                        
                        // Apply Preview Flip manually if not export
                        if(!s.isExport && s.flipV) y = s.targetH - y;
                        
                        if(first) { ctx.moveTo(x, y); first = false; }
                        else { ctx.lineTo(x, y); }
                    }
                });
                ctx.closePath();
            });
            ctx.stroke();

            if(s.isExport) {
                mesh.normalized_uvs = false;
                mesh.uvs = transformedUVs;
            }
        }

        function drawRect(ctx, u, v, w, h, s) {
            let x = u * s.scaleX;
            let y = v * s.scaleY;
            let width = w * s.scaleX;
            let height = h * s.scaleY;

            // Apply Offsets
            x += s.offX;
            y += s.offY;

            // Apply Preview Flip
            if(s.flipV) y = s.targetH - y - height; 

            ctx.strokeRect(x, y, width, height);
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + width, y + height);
            ctx.stroke();
        }

        function downloadFiles(canvas, jsonData) {
            const linkImg = document.createElement('a');
            linkImg.download = 'smart_wireframe.png';
            linkImg.href = canvas.toDataURL('image/png');
            document.body.appendChild(linkImg);
            linkImg.click();
            document.body.removeChild(linkImg);

            setTimeout(() => {
                const jsonString = JSON.stringify(jsonData, null, 2); 
                const blob = new Blob([jsonString], {type: "application/json"});
                const linkModel = document.createElement('a');
                linkModel.href = URL.createObjectURL(blob);
                linkModel.download = appState.fileName.replace('.json', '').replace('.txt', '') + "_smart.geo.json";
                document.body.appendChild(linkModel);
                linkModel.click();
                document.body.removeChild(linkModel);
                log("Download Complete!");
            }, 500);
        }

    </script>
</body>
</html>
